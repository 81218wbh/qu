(ns cfpb.qu.where
  "This namespace parses WHERE clauses into an AST and turns that AST
into a Monger query."
  (:require
   [clojure.string :as str]
   [protoflex.parse :as p]
   [cfpb.qu.where.parse-fns :refer [where-expr]]))

(defn parse
  "Parse a valid WHERE expression and return an abstract syntax tree
for use in constructing Mongo queries."
  [clause]
  (p/parse where-expr clause))

(def mongo-operators
  {:AND "$and"
   :OR "$or"
   :< "$lt"
   :<= "$lte"
   :> "$gt"
   :>= "$gte"
   :!= "$ne"})

(def mongo-opposites
  {"$lt" "$gte"
   "$lte" "$gt"
   "$gt" "$lte"
   "$gte" "$lt"})

(declare mongo-eval-not)

(defn mongo-eval
  "Take an abstract syntax tree generated by `parse` and turn it into
a valid Monger query."
  [ast]
  (cond
   (get ast :not)
   (mongo-eval-not (:not ast))
   
   (get ast :op)
   (let [{:keys [op left right]} ast]
     {(op mongo-operators) [(mongo-eval left) (mongo-eval right)]})

   (get ast :comparison)
   (let [[ident op value] (:comparison ast)
         value (mongo-eval value)]
     (if (= op :=)
       {ident value}
       {ident {(op mongo-operators) value}}))

   (get ast :bool)
   (:bool ast)
   
   :default
   ast))

(defn- mongo-eval-not [ast]
  (cond
   (get ast :not)
   (mongo-eval (:not ast))
   
   (get ast :op)
   (let [{:keys [op left right]} ast]
     (case op
       :OR {"$nor" [(mongo-eval left) (mongo-eval right)]}
       :AND {"$or" [(mongo-eval-not left) (mongo-eval-not right)]}))

   (get ast :comparison)
   (let [[ident op value] (:comparison ast)
         value (mongo-eval value)]
     (case op
       :!= {ident value}
       := {ident {"$ne" value}}
       {ident {(mongo-opposites (op mongo-operators)) value}}))

   (get ast :bool)
   (not (:bool ast))

   :default
   (not ast)))
